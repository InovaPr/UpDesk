<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Sistema de Acompanhamento de Chamados</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }

        body {
            padding: 20px;
            background-color: #f0f0f0;
        }

        #loginContainer {
            max-width: 300px;
            margin: 50px auto;
            padding: 20px;
            background: white;-
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #mainContainer {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        #slaStatistics {
            display: flex;
            justify-content: space-between;
            background-color: #f4f4f4;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
        }

        #slaStatistics .sla-stats {
            display: flex;
            gap: 20px;
        }

        #slaStatistics .sla-stats div {
            background-color: white;
            padding: 5px 10px;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        input, select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background-color: #007bff;
        }

        .ticket-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px;
            background-color: #f9f9f9;
            margin-bottom: 10px;
            border-radius: 4px;
            align-items: center;
        }

        .timer {
            font-size: 1.2em;
            font-weight: bold;
        }

        .green { background-color: #90EE90 !important; }
        .yellow { background-color: #FFFF99 !important; }
        .orange { background-color: #FFB366 !important; }
        .red { background-color: #FF9999 !important; }

        #ticketList {
            margin-top: 20px;
        }

        .error-message {
            color: red;
            margin-top: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: left;
        }

        th {
            background-color: #007bff;
        }
    </style>
</head>
<body>
    <div id="loginContainer">
        <h2>Login</h2>
        <div class="input-group">
            <label for="username">Usuário:</label>
            <input type="text" id="username" required>
        </div>
        <div class="input-group">
            <label for="password">Senha:</label>
            <input type="password" id="password" required>
        </div>
        <button onclick="login()">Entrar</button>
        <p id="loginError" class="error-message"></p>
    </div>

   <div id="mainContainer">
    <h1>Sistema de Acompanhamento de Chamados</h1>
    <button onclick="addNewTicket()">Adicionar Novo Chamado</button>
    <button onclick="showDatabase()">Visualizar Chamados</button>
    <button onclick="showGraphs()">Visualizar Graficos</button>
    <button onclick="logout()">Logout</button> <!-- Add this line -->
    <div id="ticketList"></div>

    <div id="databaseView" style="display: none;">

        <h2>Registros de Chamados</h2>
        <div class="input-group">
            <label>Filtrar por PROBLEMA:</label>
            <input list="problemaOptions" id="filterPR">
            <datalist id="problemaOptions">
                <option value="Acesso Lento"></option>
                <option value="Acréscimo de canais"></option>
            </datalist>

            <label>Filtrar por CLIENTE:</label>
            <input list="clienteOptions" id="filterCliente">
            <datalist id="clienteOptions">
                <option value="476"></option>
                <option value="490"></option>
            </datalist>

            <label>Filtrar por OPERADOR:</label>
            <input list="operadorOptions" id="filterOperador">
            <datalist id="operadorOptions">
                <option value="Castelo"></option>
                <option value="Marcelo"></option>
                <option value="kaline"></option>
                <option value="Gabriel"></option>
                <option value="Jefferson"></option>
            </datalist>
            
            <label>Filtrar por EXECUTOR:</label>
            <input list="executorOptions" id="filterEX">
            <datalist id="executorOptions">
                <option value="Airton"></option>
                <option value="Damião"></option>
                <option value="Daniel"></option>
                <option value="Alison"></option>

            </datalist>

            <label>Filtrar por STATUS DO PRAZO:</label>
            <input list="statusOptions" id="filterStatus">
            <datalist id="statusOptions">
                <option value="No Prazo"></option>
                <option value="Fora do Prazo"></option>
            </datalist>
    
            <label>Filtrar por INTERVALO DE DATAS:</label>
            <input type="text" id="filterDateRange" placeholder="Selecione o intervalo de datas">
            <button onclick="applyFilters()">Aplicar Filtros</button>
            <button onclick="downloadExcel()">Download Excel</button>
            <button onclick="clearDatabase()">Limpar Banco de Dados</button>

        <table id="databaseTable">
            <thead>
                <tr>
                    <th>TEMPO</th>
                    <th>CLIENTE</th>
                    <th>PROBLEMA</th>
                    <th>OPERADOR</th>
                    <th>EXECUTOR</th>
                    <th>HORA DE ABERTURA</th>
                    <th>ARQUIVADO POR:</th>
                    <th>HORA DE ENCERRAMENTO</th>
                    <th>TEMPO DE EXECUÇÃO</th>
                    <th>STATUS DO PRAZO</th>
                </tr>
            </thead>
            <tbody id="databaseTableBody"></tbody>
        </table>
    </div>
</div>

<div id="graphsView" style="display: none;">
    <div class="container">
        <h2>Gráficos</h2>

        <div class="charts" style="display: flex; justify-content: space-between;">

            <div class="chart-container" style="flex: 1; padding: 10px;">
                <h3>Prazos</h3>
                
                <div class="filters" style="margin-bottom: 10px;">
                    <div class="filter">
                        <label for="customerFilterPie">Clientes:</label>
                        <select id="customerFilterPie">
                            <option value="all">Todos</option>
                            <option value="476"></option>
                            
                        </select>
                    </div>
                    <div class="filter">
                        <label for="problemFilterPie">Tipo de Problema:</label>
                        <select id="problemFilterPie">
                            <option value="all">Todos</option>
                            <option value="Acesso Lento"></option>
                            <option value="Acréscimo de canais"></option>
                        
                        </select>
                    </div>
                    <div class="filter">
                        <label for="dateFilterPie">Data:</label>
                        <input type="date" id="dateFilterPie">
                    </div>
                </div>
                <canvas id="pieChart" style="max-width: 300px; max-height: 300px;"></canvas>
                <button onclick="renderGraphs()">Aplicar Filtros</button>             </div>

            <div class="chart-container" style="flex: 1; padding: 10px;">
                <h3>Problemas</h3>
                <div class="filters" style="margin-bottom: 10px;">
                    <div class="filter">
                        <label for="customerFilterBar">Clientes:</label>
                        <select id="customerFilterBar">
                            <option value="all">Todos</option>
                            <option value="476"></option>
                            <option value="490"></option>
                        </select>
                    </div>
                    <div class="filter">
                        <label for="problemFilterBar">Tipo de Problema:</label>
                        <select id="problemFilterBar">
                            <option value="all">Todos</option>
                            <option value="Acesso Lento"></option>
                            <option value="Acréscimo de canais"></option>
                            >
                        </select>
                    </div>
                    <div class="filter">

...
<div class="filter">
    <label for="dateFilterBar">Intervalo de Datas:</label>
    <input type="text" id="dateFilterBar" placeholder="Selecione o intervalo de datas">
</div>
                </div>
                <canvas id="barChart" style="max-width: 300px; max-height: 300px;"></canvas>
                <button onclick="renderGraphs()">Aplicar Filtros</button> <!-- Add this button here -->
            </div>
        </div>
        <button onclick="downloadGraphsAsWord()">Download gráficos em Word</button>
    </div>
</div>

<script>

     let socket;

    function initializeWebSocket() {
        // Substitua pela URL real do WebSocket da UOL Host
        socket = new WebSocket('wss://inovanet.ind.br/websocket');

        socket.onopen = () => {
            console.log('Conexão WebSocket estabelecida');
        };

        socket.onmessage = (event) => {
            console.log("Mensagem recebida via WebSocket:", event.data);
            const data = JSON.parse(event.data);

            if (data.tipo === 'novo_chamado') {
                console.log('Novo chamado recebido:', data.chamado);
                addNewTicket(data.chamado);
            } else if (data.tipo === 'atualizacao_chamado') {
                console.log('Chamado atualizado:', data.chamado);
                updateTicket(data.chamado);
            }
};

        socket.onclose = () => {
            console.log('Conexão WebSocket fechada. Tentando reconectar...');
            setTimeout(initializeWebSocket, 5000); // Tentar reconectar após 5 segundos
        };

        socket.onerror = (error) => {
            console.error('Erro no WebSocket:', error);
        };
    }

    async function saveTicketsState() {
    try {
        await fetch('https://inovanet.ind.br/api/chamados', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(database), // Envie o banco de dados local para o servidor
        });
        console.log('Estado dos chamados salvo no servidor.');
    } catch (error) {
        console.error('Erro ao salvar estado no servidor:', error);
    }
}

async function fetchTicketsState() {
    try {
        const response = await fetch('https://inovanet.ind.br/api/chamados');
        const data = await response.json();
        database = data; // Atualiza o banco de dados local com os dados do servidor
        updateDatabaseTable(); // Atualiza a tabela na interface
    } catch (error) {
        console.error('Erro ao buscar estado no servidor:', error);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    fetchChamadosFromServer(); // Buscar chamados ao carregar a página
});

setInterval(() => {
    fetchChamadosFromServer();
}, 5000); // Sincronize a cada 5 segundos

function archiveTicket(ticketDiv) {
    // ... (coleta dados do chamado)
    const ticket = { /* ...dados do chamado... */ };

    if (!ticket.cliente || !ticket.problema || !ticket.operador || !ticket.executor) {
        alert('Por favor, preencha todos os campos obrigatórios antes de arquivar.');
        return;
    }

    database.push(ticket); // <-- ESTE É O LOCAL DO CÓDIGO
    localStorage.setItem('ticketDatabase', JSON.stringify(database)); // <-- ESTE TAMBÉM

    // ... (remove ticket da tela, atualiza tabela, etc.)
}

function sendNewTicket(ticket) {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ tipo: 'novo_chamado', chamado: ticket }));
        } else {
            console.error('Conexão WebSocket não está aberta. Chamado não enviado.');
        }
    }


 function updateTicket(ticket) {
        const ticketDiv = document.querySelector(`[data-ticket-id="${ticket.id}"]`);
        if (ticketDiv) {
            // Atualize os campos necessários no ticketDiv
            console.log('Chamado atualizado:', ticket);
        } else {
            console.error('Chamado não encontrado para atualização:', ticket);
        }
    }

    // Inicializar WebSocket e buscar dados iniciais
    document.addEventListener('DOMContentLoaded', () => {
        initializeWebSocket();
        fetchChamadosFromServer();
    });

function renderGraphs() {
    const customerFilterPie = document.getElementById('customerFilterPie').value;
    const customerFilterBar = document.getElementById('customerFilterBar').value;
    const problemFilterPie = document.getElementById('problemFilterPie').value;
    const problemFilterBar = document.getElementById('problemFilterBar').value;
    const dateFilterPie = document.getElementById('dateFilterPie').value;
    const dateFilterBar = document.getElementById('dateFilterBar').value;

    console.log('Filters:', {
        customerFilterPie,
        customerFilterBar,
        problemFilterPie,
        problemFilterBar,
        dateFilterPie,
        dateFilterBar
    });

    let filteredPieData = database;
    let filteredBarData = database;

    if (customerFilterPie !== 'all') {
        filteredPieData = filteredPieData.filter(ticket => ticket.cliente === customerFilterPie);
    }
    if (problemFilterPie !== 'all') {
        filteredPieData = filteredPieData.filter(ticket => ticket.problema === problemFilterPie);
    }
    if (dateFilterPie) {
        const selectedDate = new Date(dateFilterPie);
        filteredPieData = filteredPieData.filter(ticket => {
            const ticketDate = new Date(ticket.inicio);
            return ticketDate.toDateString() === selectedDate.toDateString();
        });
    }

    console.log('Filtered Pie Data:', filteredPieData);

    const pieDataValues = [0, 0];
    filteredPieData.forEach(ticket => {
        if (ticket.status_prazo === 'No Prazo') {
            pieDataValues[0]++;
        } else if (ticket.status_prazo === 'Fora do Prazo') {
            pieDataValues[1]++;
        }
    });

    const pieData = {
        labels: ['Dentro do Prazo', 'Fora do Prazo'],
        datasets: [{
            data: pieDataValues,
            backgroundColor: ['#36A2EB', '#FF6384'],
            hoverBackgroundColor: ['#36A2EB', '#FF6384']
        }]
    };

    if (customerFilterBar !== 'all') {
        filteredBarData = filteredBarData.filter(ticket => ticket.cliente === customerFilterBar);
    }
    if (problemFilterBar !== 'all') {
        filteredBarData = filteredBarData.filter(ticket => ticket.problema === problemFilterBar);
    }
    if (dateFilterBar) {
        const selectedDate = new Date(dateFilterBar);
        filteredBarData = filteredBarData.filter(ticket => {
            const ticketDate = new Date(ticket.inicio);
            return ticketDate.toDateString() === selectedDate.toDateString();
        });
    }

    console.log('Filtered Bar Data:', filteredBarData);

    const barDataValues = {};
    filteredBarData.forEach(ticket => {
        const problem = ticket.problema;
        if (!barDataValues[problem]) {
            barDataValues[problem] = 0;
        }
        barDataValues[problem]++;
    });

    const barData = {
        labels: Object.keys(barDataValues),
        datasets: [{
            label: 'Chamados',
            data: Object.values(barDataValues),
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
        }]
    };

    const pieOptions = {
        responsive: true,
        maintainAspectRatio: false,
    };

    const barOptions = {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            y: {
                beginAtZero: true
            }
        }
    };

    const pieCtx = document.getElementById('pieChart').getContext('2d');
    new Chart(pieCtx, {
        type: 'pie',
        data: pieData,
        options: pieOptions
    });

    const barCtx = document.getElementById('barChart').getContext('2d');
    new Chart(barCtx, {
        type: 'bar',
        data: barData,
        options: barOptions
    });
}

function showGraphs() {
    const graphsView = document.getElementById('graphsView');
    graphsView.style.display = graphsView.style.display === 'none' ? 'block' : 'none';
    if (graphsView.style.display === 'block') {
        renderGraphs();

        flatpickr("#dateFilterPie", {
            mode: "range",
            dateFormat: "d/m/Y",
            locale: "pt",
            onChange: function(selectedDates, dateStr, instance) {
                console.log('Datas selecionadas para Pie:', dateStr);
            }
        });

        flatpickr("#dateFilterBar", {
            mode: "range",
            dateFormat: "d/m/Y",
            locale: "pt",
            onChange: function(selectedDates, dateStr, instance) {
                console.log('Datas selecionadas para Bar:', dateStr);
            }
        });
    }
}


function downloadGraphsAsWord() {
    const pieChart = document.getElementById('pieChart').toDataURL('image/png');
    const barChart = document.getElementById('barChart').toDataURL('image/png');

    const docContent = `
    <html>
    <head><meta charset="utf-8"></head>
    <body>
    <h2>Prazos</h2>
    <img src="${pieChart}" alt="Gráfico de Pizza">
    <h2>Problemas</h2>
    <img src="${barChart}" alt="Gráfico de Barras">
    </body>
    </html>
    `;

    const blob = new Blob(['\ufeff', docContent], {
        type: 'application/msword'
    });

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'graficos.doc';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

    document.addEventListener('DOMContentLoaded', () => {
    flatpickr("#filterDateRange", {
        mode: "range",
        dateFormat: "d/m/Y",
        locale: "pt",
        onChange: function(selectedDates, dateStr, instance) {
            console.log('Datas selecionadas:', dateStr);
        }
    });
});

    function downloadExcel() {
        let table = document.getElementById('databaseTable');
        let wb = XLSX.utils.table_to_book(table, {sheet: "Sheet JS"});
        XLSX.writeFile(wb, 'Chamados.xlsx');
    }


        function showDatabase() {
            const databaseView = document.getElementById('databaseView');
            databaseView.style.display = databaseView.style.display === 'none' ? 'block' : 'none';
            
            if (databaseView.style.display === 'block') {
                updateDatabaseTable();
            }
        }

function clearDatabase() {
    if (confirm('Tem certeza que deseja limpar o banco de dados?')) {
        database = [];
        localStorage.setItem('ticketDatabase', JSON.stringify(database));
        updateDatabaseTable();
    }
}

function updateDatabaseTable(filters = {}) {
    const tbody = document.getElementById('databaseTableBody');
    tbody.innerHTML = '';

    let filteredData = [...database];

    if (filters.problema) {
        filteredData = filteredData.filter(t => 
            t.problema && t.problema.toLowerCase().includes(filters.problema.toLowerCase())
        );
    }
    if (filters.operador) {
        filteredData = filteredData.filter(t => 
            t.operador && t.operador.toLowerCase().includes(filters.operador.toLowerCase())
        );
    }
    if (filters.cliente) {
        filteredData = filteredData.filter(t => 
            t.cliente && t.cliente.toLowerCase().includes(filters.cliente.toLowerCase())
        );
    }
    if (filters.executor) {
        filteredData = filteredData.filter(t => 
            t.executor && t.executor.toLowerCase().includes(filters.executor.toLowerCase())
        );
    }
    if (filters.status) {
        filteredData = filteredData.filter(t => 
            t.status_prazo && t.status_prazo.toLowerCase().includes(filters.status.toLowerCase())
        );
    }

    // Aplica filtro de data com novo tratamento
    if (filters.startDate && filters.endDate) {
        filteredData = filteredData.filter(ticket => {
            if (!ticket.inicio) return false;
            
            const ticketDate = parseDateTimeStr(ticket.inicio);
            if (!ticketDate) return false;

            // Compara apenas as datas, ignorando o horário
            return ticketDate >= filters.startDate && ticketDate <= filters.endDate;
        });
    }

    filteredData.forEach(ticket => {
        const row = tbody.insertRow();
        const cells = [
            ticket.tempo_previsto || '',
            ticket.cliente || '',
            ticket.problema || '',
            ticket.operador || '',
            ticket.executor || '',
            ticket.inicio || '',
            ticket.arquivado_por || '',
            ticket.fim || '',
            ticket.tempo_decorrido || '',
            ticket.status_prazo || ''
        ];

        cells.forEach(value => {
            const cell = row.insertCell();
            cell.textContent = value;
        });

        // Adiciona classes de cor
        if (ticket.status_prazo === 'No Prazo') {
            row.classList.add('green');
        } else if (ticket.status_prazo === 'Fora do Prazo') {
            row.classList.add('red');
        }
    });
}


    const users = [
        ["Jefferson", "123123"],
        ["Castelo", "123123"],
        ["Gabriel", "123123"],
        ["Kaline", "123123"],
        ["Virgilio", "123123"],
        ["James", "123123"],
        ["Marcelo", "123123"]
    ];

    const operadores = ["", "Castelo", "Marcelo", "kaline", "Gabriel", "Jefferson"];
    const executores = ["", "Airton", "Damião", "Daniel", "Alison"];
    const problemas = ["","Adição de equipamento","Ajuste no IPV6","Ativação de Link","Ativação de Telefonia",,];
    const ncOpcoes = ["","2", "4", "5", "8", "13", "15", "17", "18", "21", "22", "24", "26", "27", "36", "37", "40", "43", "43",

]
    let database = JSON.parse(localStorage.getItem('ticketDatabase')) || [];
    let timers = new Map();
    let accumulatedTimes = new Map();

function login() {
    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;
    
    const user = users.find(u => u[0] === username && u[1] === password);
    
    if (user) {
        localStorage.setItem('isLoggedIn', 'true');
        localStorage.setItem('username', username);
        
        document.getElementById('loginContainer').style.display = 'none';
        document.getElementById('mainContainer').style.display = 'block';
    } else {
        document.getElementById('loginError').textContent = 'Usuário ou senha incorretos';
    }
}


function checkLoginState() {
    const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
    
    if (isLoggedIn) {
        document.getElementById('loginContainer').style.display = 'none';
        document.getElementById('mainContainer').style.display = 'block';
    } else {
        document.getElementById('loginContainer').style.display = 'block';
        document.getElementById('mainContainer').style.display = 'none';
    }
}

function logout() {
    localStorage.removeItem('isLoggedIn');
    localStorage.removeItem('username');
    document.getElementById('loginContainer').style.display = 'block';
    document.getElementById('mainContainer').style.display = 'none';
}

document.addEventListener('DOMContentLoaded', () => {
    checkLoginState();
    flatpickr("#filterDateRange", {
        mode: "range",
        dateFormat: "d/m/Y",
        locale: "pt",
        onChange: function(selectedDates, dateStr, instance) {
            console.log('Datas selecionadas:', dateStr);
        }
    });
});


function saveTicketsState() {
    const ticketList = document.getElementById('ticketList');
    const tickets = [];
    
    ticketList.querySelectorAll('.ticket-row').forEach(ticketDiv => {
        const ticket = {
            tempo_previsto: ticketDiv.querySelector('input[type="text"]').value,
            cliente: ticketDiv.querySelector('select[id="CLIENTE"]').value,
            problema: ticketDiv.querySelector('select[id="PROBLEMA"]').value,
            operador: ticketDiv.querySelector('select[id="OPERADOR"]').value,
            executor: ticketDiv.querySelector('select[id="EXECUTOR"]').value,
            hora_inicio: ticketDiv.querySelector('input[id="hora_inicio"]').value,
            data_abertura: ticketDiv.querySelector('input[id="data_abertura"]').value,
            hora_fim: ticketDiv.querySelector('input[id="hora_fim"]').value,
            timerState: ticketDiv.getAttribute('data-timer-state'),
            timerType: ticketDiv.getAttribute('data-timer-type'),
            accumulatedTime: ticketDiv.getAttribute('data-accumulated-time'),
            startTime: ticketDiv.getAttribute('data-start-time')
        };
        tickets.push(ticket);
    });
    
    localStorage.setItem('openTickets', JSON.stringify(tickets));
}

function loadTicketsState() {
    const tickets = JSON.parse(localStorage.getItem('openTickets')) || [];
    tickets.forEach(ticket => {
        addNewTicket(ticket);

        if (ticket.timerState === 'running') {
            const ticketDiv = document.querySelector(`#ticketList .ticket-row:last-child`);
            if (ticketDiv) {
                const startTime = parseInt(ticket.startTime);
                const accumulatedTime = parseInt(ticket.accumulatedTime) || 0;
                const elapsedTime = (Date.now() - startTime) / 1000;

                let timeLeft;
                if (ticket.timerType === 'T') {
                    timeLeft = timeToSeconds(ticket.tempo_previsto) - elapsedTime - accumulatedTime;
                } else {
                    timeLeft = accumulatedTime + elapsedTime;
                }

                startTimer(ticketDiv, timeLeft);
            }
        }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    checkLoginState();
    loadTicketsState(); 

    flatpickr("#filterDateRange", {
        mode: "range",
        dateFormat: "d/m/Y",
        locale: "pt",
        onChange: function(selectedDates, dateStr, instance) {
            console.log('Datas selecionadas:', dateStr);
        }
    });
});

function fetchDatabaseFromServer() {
    return fetch('https://inovanet.ind.br/api/chamados')
        .then(response => response.json())
        .then(data => {
            database = data; // Atualize a variável local com os dados do servidor
            updateDatabaseTable(); // Atualize a tabela na página
        })
        .catch(error => console.error('Erro ao buscar dados do servidor:', error));
}

    function createSelect(options, id) {
        const select = document.createElement('select');
        select.id = id;
        options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option;
            opt.textContent = option;
            select.appendChild(opt);
        });
        return select;
    }
function addComment(ticketDiv) {
    const comment = prompt('Digite seu comentário:');
    if (comment) {
        const ticketId = ticketDiv.dataset.ticketId;
        comments.push({ ticketId, comment });
        alert('Comentário adicionado com sucesso!');
    }
}

function downloadCommentsAsExcel() {
    const ws = XLSX.utils.json_to_sheet(comments);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Comments");
    XLSX.writeFile(wb, 'Comments.xlsx');
}

function archiveTicket(ticketDiv) {
    validatePasswordAndExecute((username) => {
        const tempoPrevisto = ticketDiv.querySelector('input[type="text"]').value;
        const horaInicio = ticketDiv.querySelector('input[id="hora_inicio"]').value;
        const dataAbertura = ticketDiv.querySelector('input[id="data_abertura"]').value;
        const horaFim = new Date().toLocaleTimeString();
        const dataEncerramento = new Date().toLocaleDateString();

        const dataHoraAbertura = `${dataAbertura} ${horaInicio}`;
        
        // Correctly calculate the accumulated execution time
        const startTime = parseDateTimeStr(dataHoraAbertura).getTime(); // Convert start time to timestamp
        const endTime = new Date(`${dataEncerramento} ${horaFim}`).getTime(); // Convert end time to timestamp
        const accumulatedTime = endTime - startTime; // Calculate total time in milliseconds
        const tempoDecorrido = calculateTotalTimeFromMilliseconds(accumulatedTime); // Format as H:M:S

        const tempoPrevistoSeconds = timeToSeconds(tempoPrevisto);
        const tempoDecorridoSeconds = timeToSeconds(tempoDecorrido);

        let statusPrazo;
        const timerType = ticketDiv.getAttribute('data-timer-type');
        if (timerType === 'T' && tempoDecorridoSeconds <= tempoPrevistoSeconds) {
            statusPrazo = 'No Prazo';
        } else {
            statusPrazo = 'Fora do Prazo';
        }

        const ticket = {
            tempo_previsto: tempoPrevisto,
            cliente: ticketDiv.querySelector('select[id="CLIENTE"]').value,
            problema: ticketDiv.querySelector('select[id="PROBLEMA"]').value,
            operador: ticketDiv.querySelector('select[id="OPERADOR"]').value,
            executor: ticketDiv.querySelector('select[id="EXECUTOR"]').value,
            data_hora_abertura: dataHoraAbertura,
            hora_fim: `${dataEncerramento} ${horaFim}`,
            arquivado_por: username,
            inicio: dataHoraAbertura,
            fim: `${dataEncerramento} ${horaFim}`,
            tempo_decorrido: tempoDecorrido, // Correctly calculated execution time
            status_prazo: statusPrazo
        };

        if (!ticket.cliente || !ticket.problema || !ticket.operador || !ticket.executor) {
            alert('Por favor, preencha todos os campos obrigatórios antes de arquivar.');
            return;
        }


        if (timers.has(ticketDiv)) {
            clearInterval(timers.get(ticketDiv));
            timers.delete(ticketDiv);
        }

        ticketDiv.remove();

        const databaseView = document.getElementById('databaseView');
        if (databaseView.style.display === 'block') {
            updateDatabaseTable();
        }

        alert(`Chamado arquivado com sucesso!\n
            Data de abertura: ${dataAbertura} Hora de abertura: ${horaInicio}\n
            Data de encerramento: ${dataEncerramento} Hora de encerramento: ${horaFim}\n
            Tempo de execução: ${tempoDecorrido}`);
    });
}

const tempoDecorrido = calculateTotalTimeFromMilliseconds(accumulatedTime); // Format as H:M:S

function calculateTotalTimeFromMilliseconds(ms) {
    const hours = String(Math.floor(accumulatedTime / 3600000)).padStart(2, '0');
    const minutes = String(Math.floor((accumulatedTime % 3600000) / 60000)).padStart(2, '0');
    const seconds = String(Math.floor((accumulatedTime % 60000) / 1000)).padStart(2, '0');
    const tempoDecorrido = `${hours}:${minutes}:${seconds}`; // Format as 00:00:00

    return `${hours}:${minutes}:${seconds}`;
}

function saveDatabaseToServer() {
    fetch('https://inovanet.ind.br/api/saveDatabase', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(database), // Envie a variável local para o servidor
    }).catch(error => console.error('Erro ao salvar dados no servidor:', error));
}

// Chame fetchDatabaseFromServer ao carregar a página
document.addEventListener('DOMContentLoaded', () => {
    fetchDatabaseFromServer(); // Buscar os dados ao carregar a página
});

 function addNewTicket(ticket = {}) {
        const ticketList = document.getElementById('ticketList');
        if (!ticketList) {
            console.error('Ticket list container not found');
            return;
        }

        const ticketDiv = document.createElement('div');
        ticketDiv.className = 'ticket-row';
        ticketDiv.dataset.ticketId = Date.now(); // Unique identifier for the ticket

    const fields = {
        tempo_previsto: document.createElement('input'),
        CLIENTE: createSelect(ncOpcoes, 'CLIENTE'),
        PROBLEMA: createSelect(problemas, 'PROBLEMA'),
        OPERADOR: createSelect(operadores, 'OPERADOR'),
        EXECUTOR: createSelect(executores, 'EXECUTOR'),
        hora_inicio: document.createElement('input'),
        data_abertura: document.createElement('input'),
        hora_fim: document.createElement('input')
    };

    fields.tempo_previsto.type = 'text';
    fields.tempo_previsto.className = 'input-time';
    fields.tempo_previsto.placeholder = 'H:M:S';
    fields.tempo_previsto.value = ticket.tempo_previsto || '';

    fields.tempo_previsto.addEventListener('input', function (e) {
        e.target.value = e.target.value.replace(/[^0-9:]/g, ''); // Allow only numbers and colons
    });

    fields.tempo_previsto.addEventListener('blur', function (e) {
        if (e.target.value) {
            let parts = e.target.value.split(':');
            parts = parts.map(part => part.padStart(2, '0'));
            while (parts.length < 3) parts.push('00'); // Ensure HH:MM:SS format
            e.target.value = parts.slice(0, 3).join(':');
        }
    });

    fields.hora_inicio.readOnly = true;
    fields.hora_inicio.id = 'hora_inicio';
    fields.hora_inicio.value = ticket.hora_inicio || '';

    fields.data_abertura.readOnly = true;
    fields.data_abertura.id = 'data_abertura';
    fields.data_abertura.value = ticket.data_abertura || '';

    fields.hora_fim.readOnly = true;
    fields.hora_fim.id = 'hora_fim';
    fields.hora_fim.value = ticket.hora_fim || '';

    fields.CLIENTE.value = ticket.cliente || '';
    fields.PROBLEMA.value = ticket.problema || '';
    fields.OPERADOR.value = ticket.operador || '';
    fields.EXECUTOR.value = ticket.executor || '';

    Object.entries(fields).forEach(([key, field]) => {
        const label = document.createElement('label');
        label.textContent = {
            tempo_previsto: 'TEMPO PREVISTO:',
            hora_inicio: 'HORA DE INÍCIO:',
            data_abertura: 'DATA DE ABERTURA:',
            hora_fim: 'HORA FINAL:'
        }[key] || key.toUpperCase() + ':';
        ticketDiv.appendChild(label);
        ticketDiv.appendChild(field);
    });

    const timerDisplay = document.createElement('div');
    timerDisplay.className = 'timer';
    const timerType = ticket.timerType || 'T';
    const accumulatedTime = parseInt(ticket.accumulatedTime, 10) || 0;
    updateTimerDisplay(timerDisplay, accumulatedTime, timerType);
    ticketDiv.setAttribute('data-timer-type', timerType);
    ticketDiv.setAttribute('data-timer-state', ticket.timerState || 'stopped');
    ticketDiv.setAttribute('data-accumulated-time', accumulatedTime.toString());
    ticketDiv.setAttribute('data-start-time', ticket.startTime || '');

    const buttonContainer = document.createElement('div');
    const buttonActions = [
        { icon: 'fas fa-play', handler: 'iniciar' },
        { icon: 'fas fa-archive', handler: 'arquivar' },
        { icon: 'fas fa-comment', handler: 'comentar' }
    ];

    buttonActions.forEach(({ icon, handler }) => {
        const button = document.createElement('button');
        button.innerHTML = `<i class="${icon}"></i>`;
        button.onclick = () => handleTicketAction(handler, ticketDiv);
        buttonContainer.appendChild(button);
    });

    ticketDiv.appendChild(timerDisplay);
    ticketDiv.appendChild(buttonContainer);
    ticketList.appendChild(ticketDiv);

    sendNewTicket(ticket);

    // If the ticket's timer was running, restore it
    if (ticket.timerState === 'running') {
        startTimer(ticketDiv, accumulatedTime);
    }

    saveTicketsState(); // Save the updated state of tickets
}


// Ensure the function parseDateTimeStr is correctly implemented
function parseDateTimeStr(dateTimeStr) {
    const [datePart, timePart] = dateTimeStr.split(' ');
    const [day, month, year] = datePart.split('/').map(Number);
    const [hours, minutes, seconds] = timePart.split(':').map(Number);
    return new Date(year, month - 1, day, hours, minutes, seconds || 0);
}


function calculateTotalTime(startTime, endTime) {
    const start = new Date(`1970-01-01T${startTime}Z`);
    const end = new Date(`1970-01-01T${endTime}Z`);
    const diff = Math.floor((end - start) / 1000);

    const hours = Math.floor(diff / 3600);
    const minutes = Math.floor((diff % 3600) / 60);
    const seconds = diff % 60;

    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

function timeToSeconds(timeStr) {
    if (!timeStr) return 0;
    const parts = timeStr.split(':').map(Number);
    while (parts.length < 3) parts.unshift(0);
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}


// Função auxiliar para validar o formato do tempo
function isValidTimeFormat(timeStr) {
    return /^\d{1,2}:\d{1,2}:\d{1,2}$/.test(timeStr);
}

// Função startTimer corrigida
function startTimer(ticketDiv, resumeFrom = null) {
    const timerDisplay = ticketDiv.querySelector('.timer');
    const tsInput = ticketDiv.querySelector('.input-time');
    const ts = timeToSeconds(tsInput.value || '0:0:0');
    let timeLeft = resumeFrom !== null ? resumeFrom : ts;
    let timerType = ticketDiv.getAttribute('data-timer-type');

    if (timers.has(ticketDiv)) {
        clearInterval(timers.get(ticketDiv));
    }

    const startTime = parseInt(ticketDiv.getAttribute('data-start-time')) || Date.now();
    const accumulatedTime = parseInt(ticketDiv.getAttribute('data-accumulated-time')) || 0;

    ticketDiv.setAttribute('data-start-time', startTime);

    const timer = setInterval(() => {
        const elapsedTime = (Date.now() - startTime) / 1000;
        let totalTime;

        if (timerType === 'T') {
            totalTime = ts - elapsedTime - accumulatedTime;
            if (totalTime <= 0) {
                timerType = 'A';
                ticketDiv.setAttribute('data-timer-type', 'A');
                totalTime = -totalTime;
                ticketDiv.classList.add('red');
            }
        } else {
            totalTime = elapsedTime + accumulatedTime;
        }

        updateTimerDisplay(timerDisplay, totalTime, timerType);
        updateTicketColor(ticketDiv, totalTime / ts);

        ticketDiv.setAttribute('data-accumulated-time', accumulatedTime + elapsedTime);
        saveTicketsState(); // Save state periodically
    }, 1000);

    timers.set(ticketDiv, timer);
}

function pauseTimer(ticketDiv) {
    if (timers.has(ticketDiv)) {
        clearInterval(timers.get(ticketDiv));
        timers.delete(ticketDiv);

        const startTime = parseInt(ticketDiv.getAttribute('data-start-time')) || 0;
        const accumulatedTime = parseInt(ticketDiv.getAttribute('data-accumulated-time')) || 0;
        const elapsedTime = (Date.now() - startTime);
        const newAccumulatedTime = accumulatedTime + elapsedTime;

        ticketDiv.setAttribute('data-accumulated-time', newAccumulatedTime);
        saveTicketsState(); // 
    }
}

function getTimerValue(ticketDiv) {
    const timerDisplay = ticketDiv.querySelector('.timer').textContent;
    const [, timeStr] = timerDisplay.split(': ');
    const [hours, minutes, seconds] = timeStr.split(':').map(Number);
    return hours * 3600 + minutes * 60 + seconds;
}


function updateTimerDisplay(display, time, prefix) {
    const hours = Math.floor(time / 3600);
    const minutes = Math.floor((time % 3600) / 60);
    const seconds = time % 60;
    display.textContent = `${prefix}: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}


function updateTicketColor(ticketDiv, percentage) {
    ticketDiv.className = 'ticket-row';
    if (percentage > 0.75) {
        ticketDiv.classList.add('green');
    } else if (percentage > 0.5) {
        ticketDiv.classList.add('yellow');
    } else if (percentage > 0.2) {
        ticketDiv.classList.add('orange');
    } else {
        ticketDiv.classList.add('red');
    }
}



        function isValidTimeFormat(timeStr) {
            return /^\d{1,2}:\d{1,2}:\d{1,2}$/.test(timeStr);
        }

        function timeToSeconds(timeStr) {
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            return hours * 3600 + minutes * 60 + seconds;
        }

function handleTicketAction(action, ticketDiv) {
    switch(action) {
        case 'iniciar':
            validatePasswordAndExecute(() => {
                if (ticketDiv.getAttribute('data-timer-state') === 'stopped') {
                    const tsInput = ticketDiv.querySelector('.input-time');
                    if (!tsInput || !tsInput.value || !isValidTimeFormat(tsInput.value)) {
                        alert('Por favor, insira um tempo válido no formato H:M:S');
                        return;
                    }
                    const currentTime = new Date().toLocaleTimeString();
                    const currentDate = new Date().toLocaleDateString();
                    const horaInicioInput = ticketDiv.querySelector('input[id="hora_inicio"]');
                    const dataAberturaInput = ticketDiv.querySelector('input[id="data_abertura"]');
                    if (horaInicioInput) {
                        horaInicioInput.value = currentTime;
                    }
                    if (dataAberturaInput) {
                        dataAberturaInput.value = currentDate;
                    }
                    startTimer(ticketDiv);
                    ticketDiv.setAttribute('data-timer-state', 'running');
                    saveTicketsState();
                }
            });
            break;

        case 'arquivar':
            archiveTicket(ticketDiv);
            saveTicketsState();
            break;

        case 'comentar':
            addComment(ticketDiv);
            break;
    }
}

function calculateTotalTimeFromMilliseconds(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}


        function startTimer(ticketDiv, resumeFrom = null) {
            const timerDisplay = ticketDiv.querySelector('.timer');
            const tsInput = ticketDiv.querySelector('.input-time');
            const ts = timeToSeconds(tsInput.value || '0:0:0');
            let timeLeft = resumeFrom !== null ? resumeFrom : ts;
            let timerType = ticketDiv.getAttribute('data-timer-type');

            if (timers.has(ticketDiv)) {
                clearInterval(timers.get(ticketDiv));
            }

            const startTime = Date.now(); // Capture the start time
            ticketDiv.setAttribute('data-start-time', startTime);

            const timer = setInterval(() => {
                if (timerType === 'T' && timeLeft > 0) {
                    timeLeft--;
                    updateTimerDisplay(timerDisplay, timeLeft, 'T');
                    updateTicketColor(ticketDiv, timeLeft / ts);

                    if (timeLeft === 0) {
                        timerType = 'A';
                        ticketDiv.setAttribute('data-timer-type', 'A');
                        timeLeft = 0;
                        ticketDiv.classList.add('red');
                    }
                } else {
                    timeLeft++;
                    updateTimerDisplay(timerDisplay, timeLeft, 'A');
                    ticketDiv.classList.add('red');
                }
            }, 1000);

            timers.set(ticketDiv, timer);
}



        function validatePasswordAndExecute(callback) {
            const username = prompt('Digite seu nome de usuário:');
            const password = prompt('Digite sua senha:');
            
            const user = users.find(u => u[0] === username && u[1] === password);
        
            if (user) {
                callback(username);
            } else {
                alert('Usuário ou senha incorretos!');
        }
    }


        function calculateTotalTime(startTime, endTime) {
            const start = new Date(`1970-01-01T${startTime}Z`);
            const end = new Date(`1970-01-01T${endTime}Z`);
            const diff = Math.floor((end - start) / 1000);

            const hours = Math.floor(diff / 3600);
            const minutes = Math.floor((diff % 3600) / 60);
            const seconds = diff % 60;

            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}


        function showDatabase() {
            const databaseView = document.getElementById('databaseView');
            databaseView.style.display = databaseView.style.display === 'none' ? 'block' : 'none';
            if (databaseView.style.display ==='block') {
                updateDatabaseTable();
            }
        }


function applyFilters() {
    const filterDateRange = document.getElementById('filterDateRange').value;
    const filterPR = document.getElementById('filterPR').value;
    const filterEX = document.getElementById('filterEX').value;
    const filterStatus = document.getElementById('filterStatus').value;
    const filterCliente = document.getElementById('filterCliente').value;
    const filterOperador = document.getElementById('filterOperador').value; // Add this line

    let startDate = null;
    let endDate = null;

    if (filterDateRange) {
        const dates = filterDateRange.split(' to ');
        if (dates[0]) {
            startDate = parseDateTimeStr(dates[0]);
            if (startDate) {
                startDate.setHours(0, 0, 0, 0);
            }
            
            if (dates[1]) {
                endDate = parseDateTimeStr(dates[1]);
                if (endDate) {
                    endDate.setHours(23, 59, 59, 999);
                }
            } else {
                // Se só uma data foi selecionada, usa ela como início e fim
                endDate = parseDateTimeStr(dates[0]);
                if (endDate) {
                    endDate.setHours(23, 59, 59, 999);
                }
            }
        }
    }

    const filters = {
        problema: filterPR,
        executor: filterEX,
        status: filterStatus,
        cliente: filterCliente,
        operador: filterOperador, // Add this line
        startDate,
        endDate
    };

    updateDatabaseTable(filters);
}

function parseDateTimeStr(dateTimeStr) {
    if (!dateTimeStr) return null;
    
    try {

        if (dateTimeStr.includes(' ')) {
            const [dateStr, timeStr] = dateTimeStr.split(' ');
            const [day, month, year] = dateStr.split('/').map(Number);
            return new Date(year, month - 1, day);
        }
        // Se a string contém apenas data
        const [day, month, year] = dateTimeStr.split('/').map(Number);
        return new Date(year, month - 1, day);
    } catch (e) {
        console.error('Erro ao converter data:', dateTimeStr, e);
        return null;
    }
}



function formatDateTime(date) {
    return date.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}


function clearDatabase() {
    if (confirm('Tem certeza que deseja limpar o banco de dados?')) {
        database = [];
        saveDatabaseToServer(); // Atualize o servidor
        updateDatabaseTable();
    }
}

    </script>
</body>
</html>
